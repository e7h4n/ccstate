import { expect, test, vi } from 'vitest';
import { command, computed, state } from '../signal/factory';
import { createStore } from '../store/store';

/* 
WIP

This case will produce two unhandled rejections
The first one is the evaluation of promise$ when store.sub is called
The second one is the second promise generated by promise$ when store.set is called
The second one can be resolved by getting promise$ in the sub callback and then catching it
The first one has no chance to be handled, it can only be dealt with in the framework
 */
test.skip('sub to a async computed will rise unhandled rejection', async () => {
  const reload$ = state(0);
  let count = 0;
  const promise$ = computed((get) => {
    get(reload$);
    return Promise.resolve().then(() => {
      throw new Error(`test error ${String(count++)}`);
    });
  });

  let executed = false;
  const store = createStore();
  store.sub(
    promise$,
    command(() => {
      executed = true;
    }),
  );

  store.set(reload$, (x) => x + 1);

  await vi.waitFor(() => {
    expect(executed).toBe(true);
  });
});
